(page "index.html"
  (:require
    [data.index :as d]
    [clojure.string :as string]))

(def limit (Math/min (count d/upgrades) (count d/products)))

(defc god true)
(defc total-clicks 0)
(defc clicks 0)
(defc add-every 0)
(defc sales 0)
(defc levels (reverse (range 1 limit)))
(defc sell-log (vec (replicate limit 0)))
(defc upgrade-log (vec (replicate limit 0)))

(defn click-fn [func] (do
  (swap! clicks func)
  (swap! total-clicks func)))
(defn level-value-fn [n]
  (+
    (Math/pow n 4)
    (* 10 n)))
(defn buy-cost [n] (* 10 n))
(defn sell-cost [n] (* 2 n))
(defn log [level which]
  (do
    (reset! which (update-in @which [level] inc))))

(js/setInterval #(click-fn (fn [m] (+ m @add-every))) 1000)

; upgrade: add-every go up by value in upgrade lookup
;       sales go down by the value of the key in the upgrade lookup
(defelem upgrade-btn
  [{:keys [level value]} kids]
  (let [text (d/upgrades level)
      func #(swap! add-every (fn [m] (+ m level)))
      func2 #(swap! sales (fn [m] (- m value)))
      func3 #(log level upgrade-log)
      func-all (fn [] (func) (func2) (func3))
      button-text (str text " ($" value ")")]

    (button :disabled (cell= (> value sales)) :click func-all button-text kids)
    ))

; sell: sales go up by value in sales lookup
;       words go down by the value of the key in the sales lookup
(defelem sell-btn
  [{:keys [level out in ]} kids]
  (let [text (d/products level)
      func #(swap! sales (fn [m] (+ m in)))
      func2 #(swap! clicks (fn [m] (- m out)))
      func3 #(log level sell-log)
      func-all (fn [] (func) (func2) (func3))
      button-text (str text " (" out " words @ $" in ")" )]

    (button :disabled (cell= (> out clicks)) :click func-all button-text kids)
  ))

(html
  (head
    (link :href "app.css" :rel "stylesheet" :type "text/css"))
  (body
    (h3 clicks " words")
    (h3 "$" sales " income")
    (h5 "Creativity boost of " add-every " words every second")
    
    (button :click #(click-fn inc) "Write a word")

    (if-tpl god 
      (div
      (for-tpl [level levels]
        (let [n (level-value-fn @level)]
          (button :click #(click-fn (fn [m] (+ m n))) n)))))
    
    (div :class "wrapper"
      (div :class "upgrade"
        (h4 "Upgrade")
        (for-tpl [level levels]
          (let [value (buy-cost @level)
              parent (cell= (upgrade-log (- level 1)))]
            (div
              (cell=
                (div
                  (if-tpl (not= 0 parent)
                    (p (upgrade-btn :level level :value value)))
                  (if-tpl (= level 1)
                  (p (upgrade-btn :level level :value value)))
              ))))))

      (div :class "sell"
        (h4 "Sell")
        (for-tpl [level levels]
          (let [out (level-value-fn @level)
              in (sell-cost @level)
              parent (cell= (sell-log (- level 1)))]
            (div
              (cell= 
                (div 
                  (if-tpl (not= 0 parent)
                    (p (sell-btn :level level :out out :in in)))
                  (if-tpl (= level 1)
                    (p (sell-btn :level level :out out :in in)))
              ))))))
    ) ; wrapper
      
    (if-tpl god
      (div :class "debug"

        (h4 "Grand total " total-clicks)

        (h4 "Sell log "
          (for-tpl [l sell-log]
            (span l "-")))
        (h4 "Upgrade log "
          (for-tpl [l upgrade-log]
          (span l "-")))

        (h4 "Upgrades")
        (table
          (thead
            (tr
              (td "Name")
              (td "Cost")
              (td "Bump")))
          (tbody
        (for-tpl [level levels]
          (let [level-exp (level-value-fn level)
                text (d/upgrades @level)
                price (buy-cost @level)]
              (tr
                (td text)
                (td price)
                (td level " every second"))))))

        (h4 "Sell")
        (table
          (thead
            (tr
              (td "Name")
              (td "Words")
              (td "Cash")))
          (tbody
        (for-tpl [level levels]
          (let [level-exp (level-value-fn @level)
                text (d/products @level)
                price (sell-cost @level)]
              (tr
                (td text)
                (td level-exp)
                (td price))))))
      )) ; if god
    ))
